function InitialGuess = setInitialGuess(System, Setup)
%SETINITIALGUESS - sets InitialGuess cell for LTO.
%
%  Syntax:
%     InitialGuess = SETSYSTEM(System, Setup)
%
%  Description:
%     Produces InitialGuess(State) cell for LTO using the System cell and the
%     setup cell
%
%  Inputs:
%     System - system information
%			[nPhase,1] = size(System); cell = class(System)
%		Setup - setup for the initialization
%			[nPhase,1]  = size(Setup); cell = class(phaseBody)
%
%  Outputs:
%     System - cell with system parameters in it.
%			[nPhase,1] = size(System); cell = class(System)
%			System.dynamics - cell with dynamics information
%			System.parameter - struct with system parameters
%				mu - gravitational parameter(2BP, km^2/sec^3)
%					- mass ratio(CR3BP, n.d.)
%				lstar - characteristic length(km)
%				tstar - characteristic time(s)
%				mu1 - gravitational parameter of 1st primary(CR3BP, km^2/sec^3)
%				mu2 - gravitational parameter of 2nd primary(CR3BP, km^2/sec^3)
%
%  Examples:
%     nPhase = 2;
%		phaseBody{1,1} = {'Earth', 'Moon'};
%		phaseBody{2,1} = {'Earth', 'Moon'};
%		System = setSystem(nPhase, phaseBody);
%
%  Other m-files required: SETGLOBALVARIABLE
%  Subfunctions: SETSYSTEM2BP, SETSYSTEMCR3BP
%
%   Author: Beom Park
%   Date: 01-Feb-2020; Last revision: 16-Feb-2020


% if Setup.transferType ... : If you are using manifolds. Room for improvements.

times = 0; % initialization for distinction from the function "times"
nodes = 0;

nPhase = length(System);

InitialGuess = cell(nPhase,1);

for iPhase = 1:nPhase
	s = Setup.Phase{iPhase,1}.s;
	nRev = Setup.Phase{iPhase,1}.nRev;
	isATD = strcmp(Setup.Phase{iPhase,1}.orbitSource, 'atd');
	isUser = strcmp(Setup.Phase{iPhase,1}.orbitSource, 'user');
	
	if isATD
		load(Setup.Phase{iPhase,1}.orbitName)
		isJC = strcmp(Setup.Phase{iPhase,1}.orbitSelect{1}, 'JC');
		nOrbit = length(times);
		mu = System{iPhase}.parameter.mu;
		if isJC
			% Choose the orbit with JC that is closest to the input JC
			targetJC = Setup.Phase{iPhase,1}.orbitSelect{2};
			targetJCArray = ones(1,nOrbit)*targetJC;
			JCArray = cell2mat(JC);
			diffJCArray = abs(targetJCArray - JCArray);
			[diffJC, orbitIndex] = min(diffJCArray);
			fprintf('Phase %d, Set JC: %d, Orbit JC: %d, difference: %d\n', ...
				iPhase, targetJC, JCArray(orbitIndex), diffJC);
			InitialGuess{iPhase, 1}.stateInitial = nodes{orbitIndex}(1,:); % initial condition
			period = times{orbitIndex}(end); % period
		else
			error('Currently only supports JC orbit selection');
		end
	elseif isUser
		
	else
		error('Currently supports atd or user input orbits')
	end
	
	
	if iPhase == 1
		InitialGuess{iPhase, 1}.initialConstraint = ...
			[InitialGuess{iPhase, 1}.stateInitial, 1]';
	else
		if iPhase == nPhase
			InitialGuess{iPhase, 1}.finalConstraint = ...
				stateOneRev(1, 1:6)'; % open to change, only constrain 6 states
		end
	end
	
	InitialGuess{iPhase, 1}.slack = [];
	
	if Setup.plot{1}
		stateSegmentMatrix = zeros(s*nRev+1,7);
		for iSegment = 1:InitialGuess{iPhase, 1}.nSegment+1
			stateSegmentMatrix(iSegment, :) = stateMatrix(3*(iSegment-1)+1, :);
		end
		
		figure(Setup.plot{2})
		commonAxisSetting;
		CR3BPAxisSetting;
		plot3(stateSegmentMatrix(:,1), stateSegmentMatrix(:,2), stateSegmentMatrix(:,3), 'k.', 'linewidth', 2.0)
		plot3(stateMatrix(:,1), stateMatrix(:,2), stateMatrix(:,3), 'b-', 'linewidth', 1.0);
	end
	
	clear stateOneRev;
end % iPhase for loop

if Setup.plot{1}
	figure(Setup.plot{2})
	earthPlot = drawEarth(mu);
	moonPlot = drawMoon(mu);
	lpPlot = drawLagrangianPoints(mu, Setup.plot{3});
end

end


function InitialGuessPhase = setInitialGuessPhase(s, nRev, stateInitial, period)
%propagateStateInitial - sets InitialGuess cell for each phase by propagation.

tSegment = linspace(0, period, s+1)';
intRev = floor(nRev); % integer rev number of the given nRev
isInt = (intRev == nRev); % is Integer boolean

if nRev < 1
	error('At least one revolution needed for each phase')
end
stateOneRev = propagateStateInitial(s, tSegment, stateInitial);

if isInt
	nSegment = s*nRev;
else
	extraRev = nRev - intRev; % What is the 0.xxxx revolution remaining?
	sExtra = ceil(s*addRev); % additional number of the segments for the extra rev
	tExtra = linspace(0, period*extraRev, sExtra+1);
	stateExtra = propagateStateInitial(sExtra, tExtra, stateInitial);
	nSegment = s*nRev + sExtra;
end

stateMatrix = nan(3*nSegment+1, 7);
for iRev = 1:intRev
	if iRev < intRev
		stateMatrix(3*s*(iRev-1)+1:3*s*iRev, :) = stateOneRev;
	elseif isInt
		stateMatrix(3*s*(iRev-1)+1:3*s*iRev+1, :) = ...
			[stateOneRev; stateOneRev(1, :)];
	else
		
		stateMatrix(3*s*(iRev-1)+1:3*s*iRev+1, :) = ...
			[stateOneRev; stateOneRev(1, :)];
	end % if loop
end % iRev for loop
stateArray = reshape(stateMatrix', [7*(3*s*nRev + 1), 1]);

time = zeros(s*nRev+1, 1);
for iRev = 1:nRev
	if iRev < nRev
		time(s*(iRev-1)+1: s*iRev) = tSegment(1:end-1)+(iRev-1)*period;
	else
		time(s*(iRev-1)+1: s*iRev+1) = ...
			[tSegment(1:end-1)+(iRev-1)*period; tSegment(1) + nRev*period];
	end
end

controlMatrix = repmat([1e-10, 0, 0], [s*nRev 1]); % play with numbers if you want
controlArray = reshape(controlMatrix', [3*s*nRev, 1]);



end

% Converted to column vector, transpose needed to make the dimensions right
InitialGuessPhase.state = stateArray;
InitialGuessPhase.control = controlArray;
InitialGuessPhase.timeSegment = time;
InitialGuessPhase.nSegment = nSegment; % Remember that segment requires two nodes
InitialGuessPhase.t0 = 0; % Time offset of the rotating frame

end